---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  fig.align = "center"
)
```
# pedbuildr

The goal of pedbuildr is to reconstruct small/medium-sized pedigrees from genotype data. The most important functions of the package are

* `buildPeds()` : generates all pedigrees containing a given set of members
* `reconstruct()`: finds the most likely pedigree given the available genotype data

## Installation
The development version of pedbuildr is available from GitHub:
``` r
remotes::install_github("magnusdv/pedbuildr")
```

Load the package into R as follows:
```{r}
library(pedbuildr)
```

# Building pedigree lists

Suppose we want to find all pedigrees linking 3 individuals: two males and one female, labeled `1`, `2` and `3` respectively. Using the default restriction to connected pedigrees, `buildPeds()` identifies 105 such pedigrees:
```{r}
plist = buildPeds(ids = 1:3, sex = c(1, 1, 2))
length(plist)
```

Here are some of them: 

```{r fig.height=2, fig.width = 8}
plotPeds(plist[c(1, 20, 50, 105)])
```

The function `plotPeds()` is a thin wrapper around `pedtools::plot.ped()`, and highlights the original individuals in each pedigree. 

## Restricting the pedigree search

With more than a handful individuals, the number of pedigrees quickly becomes uncontrollably large. Hence it becomes vital to impose restrictions on the pedigree space. 

#### Linear inbreeding
As a further restriction, one may disallow certain types of inbreeding. Many of the pedigrees found above contain matings between parent-offspring, or even grandparent-grandchild. In many practical cases these may be irrelevant. To skip pedigrees with such features, we add `maxLinearInbreeding = 0`. 

```{r}
plist2 = buildPeds(ids = 1:3, sex = c(1, 1, 2), maxLinearInbreeding = 0)
length(plist2)
```

If we set `maxLinearInbreeding = 1` instead, then parent-child mating is allowed, but not grandparent-grandchild or higher separations.

#### Known parent-child pairs
Known parent-child pairs are conveyed to `buildPeds()` using the `knownPO` parameter. For instance, in our running example suppose we know that 2 and 3 form a parent-child pair (in some order).

```{r}
plist3 = buildPeds(ids = 1:3, sex = c(1, 1, 2), maxLinearInbreeding = 0, 
                   knownPO = list(2:3))
length(plist3)
```

Here is a selection of these pedigrees:

```{r fig.height=2, fig.width = 8}
plotPeds(plist3[c(2, 3, 9, 18)])
```

#### Further restrictions on parent-child pairs
We may also know that certain pairs are *not* parent-child; this can be imposed by using the `notPO` parameter. Another option is to set `allKnown = TRUE`, meaning that `knownPO` should be taken as the complete list of parent-child pairs among the input individuals. We add this to our running example:

```{r}
plist4 = buildPeds(ids = 1:3, sex = c(1, 1, 2), maxLinearInbreeding = 0, 
                   knownPO = list(2:3), allKnown = TRUE)
length(plist4)
```

Here are the remaining pedigrees:
```{r fig.height=4, fig.width = 8.5}
plotPeds(plist4)
```

## Which pedigrees are included in the `buildPeds()` algorithm?
TODO

# Pedigree reconstruction
The aim of this section is to show how to perform pedigree reconstruction. We start with the "true" pedigree and simulate some marker data for it. We will then try to reconstruct it from the marker data.

## Example
Suppose the true relationship between individuals `1`, `2` and `3` is as follows:

```{r echo = F, fig.height = 2.8, fig.width = 3}
y = nuclearPed(fa = "fa", mother = "mo", children = 1:2)
y = addDaughter(y, parent = 2, id = 3, verbose = F)
plot(y, col = list(red = 1:3), shaded = 1:3, symbolsize = 1.2, id=1:3, margin = c(1,1,2,1))
```

To generate some data, we create the true pedigree and simulate 10 markers (each with 4 alleles). The simulation is done with `markerSim()` from the `forrel` package.

```{r}
x = nuclearPed(fa = "fa", mother = "mo", children = 1:2)
x = addDaughter(x, parent = 2, id = 3)
# plot(x)

# Simulate
x = forrel::markerSim(x, N = 10, ids = 1:3, alleles = 1:4, verbose = F, seed = 123)
x
```


Now let us try to reconstruct the pedigree from the data, using the `reconstruct()` function. When we feed `x` into this function, it will extract the allele matrix, marker attributes and gender data, but strip the pedigree information. It will then call our friend `buildPeds()` from the previous section to generate a list of candidate pedigrees. By default In this example we won't impose any restrictions on the pedigree space, so we simply indicate the genders.
```{r}
result = reconstruct(x)
```

The function `plotBestPeds()` show the pedigrees with the highest likelihood:

```{r fig.height = 4, fig.width = 7}
plotBestPeds(result, top = 6)
```

The correct pedigree was the most likely one, but only just so! With more markers the difference would have been bigger.

