---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  fig.align = "center"
)
```
# pedbuildr

The goal of **pedbuildr** is to reconstruct small/medium-sized pedigrees from genotype data. 

## Installation
The development version of **pedbuildr** is available from GitHub:
```{r, eval = FALSE}
remotes::install_github("magnusdv/pedbuildr")
```

Load the package into R as follows:
```{r}
library(pedbuildr)
```

## A reconstruction example
To get started, we demonstrate how to reconstruct the pedigree connecting three individuals from their genotypes at 100 SNP markers. The (simulated) genotypes are contained in the dataset `trioData` built-in to **pedbuildr**. Here are the first few columns:

```{r}
trioData[, 1:10]
```

The first thing to do is to convert the data into pedigree object, using the `as.ped()` function from **pedtools**.
```{r}
x = as.ped(trioData, locusAttributes = "snp-12")
summary(x)
```
The `locusAttributes` argument tells R that all the markers are diallelic with alleles 1 and 2. By default, the alleles have equal frequencies.

To reconstruct the pedigree, simply run `reconstruct()`:
```{r}
res = reconstruct(x)
```

The most likely pedigrees are plotted as follows.
```{r reconstruct-trio, fig.height = 4, fig.width = 8}
plot(res, top = 6)
```

## Further options
*A priori* there are infinitely many possible pedigrees connecting a set of individuals. (For example, two individuals may be *k*'th cousins for any *k* = 1,2,... .) In order to obtain a manageable search space, `reconstruct()` offers a range of restriction parameters:

* `extra`: The number of extra individuals allowed to connect the original individuals. (See further explanations below.)
* `age`: A character vector describing age inequalities. For example, `age = c("A > B,C", "B > D")` excludes B and C as ancestors of A,
and D as an ancestor of B (but no assumption is made for C vs. D).
* `inferPO`: If TRUE, an initial stage of pairwise IBD estimation is done, in order to infer certain parent-child pairs, as well as certain non-parent-child pairs. 
* `knownPO`: Known parent–offspring pairs.
* `notPO`: Pairs known not to be parent–offspring.
* `allKnown`: If TRUE, then `knownPO` is the complete list of parent–offspring pairs.
* `noChildren`: Individuals known to have no children.
* `linearInb`: The allowed level of inbreeding between linear descendants. For example, `linearInb = 1` allows mating between
parent–child, but not grandparent–grandchild. Set to FALSE to disallow all inbreeding of this type.
* `connected`: If TRUE (default), only connected pedigrees are considered.
* `sexSymmetry`: If TRUE (default) pedigrees are considered equal if they differ only in the
sexes of the added parents, e.g., paternal versus maternal half-siblings.

Let us re-run the reconstruction of `trioData` adding a few of these restrictions. We allow 3 extra individuals and indicate that individual 1 is older than the others. Furthermore, we ask the program to infer parent-child relationships automatically, and disallow linear inbreeding.
```{r}
res2 = reconstruct(x, extra = 3, age = "1 > 2,3", inferPO = TRUE, linearInb = FALSE)
```
The most likely results this time are shown below:
```{r reconstruct-trio-2, fig.height = 4, fig.width = 8}
plot(res2, top = 6)
```

We see that the same pedigree "wins", but some esoteric alternatives have appeared among the runners-up.

## More about `extra`
Arguably the most important parameter to `reconstruct()` is `extra`, which controls the size of the pedigrees to consider. It can be either a nonnegative integer, or the word "parents". If an integer, it sets the maximum number of extra members used to connect the original individuals. (The final pedigrees may contain further extras still, since missing parents are added at the end.)

If `extra = "parents"`, a special algorithm is invoked. First all directed acyclic graphs between the original individuals are generated, and then parents are added in all possible ways. This is (currently) the default behaviour, since it avoids setting an *ad hoc* number of "extras". However, it only works well in relatively small cases.
